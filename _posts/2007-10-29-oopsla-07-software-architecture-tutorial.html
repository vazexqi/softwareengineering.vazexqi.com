--- 
layout: post
typo_id: 2225
title: "OOPSLA '07: Software Architecture Tutorial"
---
<small>
	The next few posts will be about OOPSLA 2007 and the title of the articles will be appended with "OOPSLA 07". Those articles will be written in a more colloquial manner since they will be mostly based on my personal experiences there.
</small>

<p>I was fortunate enough to have the opportunity to go to <a href="http://www.oopsla.org/oopsla2007/index.php?page=home/" title="OOPSLA 2007">OOPSLA</a> this year. I say fortunate because I had to apply for a Canadian visa; and based on past experiences it can either be a painless ordeal or one where you are unsure what you have done to not deserve one. Anyway, all went well, and after 15 hours of driving and 12 hours of recuperative sleep -- I was not able to sleep in the van -- I attended the first day of OOPSLA without any problems.</p>

<p>The first day was relatively easy-going since I was not signed up for any of the symposiums and could freely choose which two tutorials (or none) that I wanted to attend. I chose the tutorials on Software Architecture by <a href="http://stal.blogspot.com/" title="Hitchhiker's Guide to Software Architecture and Everything Else - by Michael Stal">Michael Stal</a> of <a href="http://www.amazon.com/Pattern-Oriented-Software-Architecture-System-Patterns/dp/0471958697" title="Amazon.com: Pattern-Oriented Software Architecture Volume 1: A System of Patterns: Books: Frank Buschmann,Regine Meunier,Hans Rohnert,Peter Sommerlad,Michael Stal"><em>Pattern-Oriented Software Architecture</em></a> fame.</p>

<p>The first tutorial was during the morning session and was entitled <em>High Quality Software Architecture</em>. It was an interesting tutorial and I think I was the youngest person in the room. The tell-tale signs of balding heads indicated that most of the other attendees were professional software architects that were here to learn the secrets of the trade from Stal himself. Anyway, the first part of the talk was essentially a nice review of the material that I had read about a year ago when I took the Advanced Software Engineering class. In fact, I wrote articles on the books and papers that we read for that class here in this blog. Stal was using the same terms an definitions from the <a href="http://www.amazon.com/Software-Architecture-Practice-Len-Bass/dp/0201199300" title="Amazon.com: Software Architecture in Practice: Books: Len Bass,Paul Clements,Rick Kazman"><em>Software Architecture in Practice</em></a> book. It was interesting to actually see how someone else who interpret that book since it was a rather academic book and it was hard to actually find someone else to discuss about it.</p>

<p>Stal emphasized three main issues that was only lightly touched upon in the book. And I agree with him that these three topics will help promote higher quality software architecture:
<ul>
	<li><em>Clear architecture vision</em>: This is similar to the metaphor in XP or the ubiquitous language in Domain Driven Design. Essentially it means that the architecture should be driven by a clear idea of what you are trying to achieve. And the architecture should strive to maintain this goal in every aspect possible.</li>
	<li><em>Iterative Development</em>: This is really important. Developers usually think of architecture as something that must always be done up-front. There is some truth to this since if you get the architecture (vs the design; see <a href="http://softwareengineering.vazexqi.com/articles/2006/08/31/architecture-design-and-implementation" title="Architecture, design and implementation">this</a> for an explanation on the differences) wrong then there is a heavy price to pay in terms of development efforts. Stal solves this by introducing the concept of the <em>baseline</em>. The baseline is the <em>core</em> of the architecture that needs to be done right and will not change throughout the entire development cycle. The baseline is determined from a set of prioritized requirements from the stakeholders. Only the most important requirements shape the architecture of the baseline; the remaining requirements will be acted on later in an incremental manner. This balance on what to add <em>first</em> and what to add <em>later</em> makes sense: unlike design, software architecture will definitely permeate the entire system so it is essential to at least get the important aspects right the first time.</li>
	<li><em>Testing</em>: It is necessary to be able to test that your system supports certain requirements. It is usually commonplace now to have automated tests for most of the functional requirements of the system. Stal claims that it is necessary to have tests as well for the system architecture. These tests need <a href="http://www.testing.com/writings/classic/mistakes.html#automating_all_tests" title="Classic Testing Mistakes">not be automated fully</a> of course but they should exist nonetheless. Either doing it through a code review or a formal inspection would reveal missing requirements in the architecture. I talked to Stal about using <a href="http://en.wikipedia.org/wiki/Architecture_description_language" title="Architecture description language - Wikipedia, the free encyclopedia">executable Architectural Description Languages</a>(ADL) to verify the architecture and he says that most of the time that approach is not feasible since it requires a domain expert on the ADL itself <a href="http://softwareengineering.vazexqi.com/articles/2006/12/05/archjava" title="ArchJava">reaffirming</a> what I thought about ADLs in the first place.</li>
</ul>	
</p>

<p>The afternoon session was on <em>Refactoring Software Architecture</em>. Stal admitted that what he was going to present was based on preliminary work but nonetheless he felt that it was essential enough to warrant a tutorial. I completely agree with him especially since he too mentioned the <strong>Grand Unified Theory of Refactoring</strong> at the end of his talk and if we have any chance of finding one we had to start thinking of a lot more about software in terms on refactoring and program transformation. Like Fowler, Stal motivated the indicators of architecture refactoring in terms of <em>architecture smells</em> or what he terms the lack of the following qualities:
<ul>
	<li>Pattern Density</li>
	<li>Symmetry</li>
	<li>Expressiveness</li>
	<li>Simplicity</li>
	<li>Orthogonality</li>
	<li>Emergent behavior</li>
</ul>	
</p>

<p>The list of refactorings that he presented were based in the spirit of the original refactorings by Fowler: he used a pattern language to describe them. When I first saw the first few refactorings that he presented I was confused by the scope of it: were they architecture refactorings or design refactorings? And this is where the distinctions in the paper <a href="http://softwareengineering.vazexqi.com/articles/2006/08/31/architecture-design-and-implementation" title="Architecture, design and implementation"><em>Architecture, Design and Implementation</em></a> might be useful. When I asked Stal, he explained that he treats refactorings that could have a percolating impact to be an architectural refactoring. So when you refactor something and it affects things below it then it is probably an architectural refactoring pattern. There is still this nagging feeling inside me that thinks that architectural refactorings might not be behavior preserving -- the quintessential definition of what a refactoring is -- but I just cannot come up with an example of this. So I could be wrong about this.</p>

<p>Stal has a list of roughly 30 refactorings. But the two that most interested me were <em>Aspectize</em> and <em>Integrate DSLs</em>. The former being that you might need to address some cross-cutting concern and use an aspect-oriented approach to solve it. This is actually the few times that I have seen someone promote aspects in an appropriate manner. Usually people are vehemently <em>for</em> or <em>against</em> aspect-oriented programming. Stal however, presented a clear case where aspects can actually be a good approach. The second pattern is all about not being reserved on using a Domain Specific Language for your architecture if you need one. Again, I think that the time for thinking in more than one language has come and this is one way to make good use of that approach. Software architecture can be a complex beast and while it might be usually over-kill to use AOP and DSLs for normal projects, architecture could be the key area where they should both have relevant roles.</p>

<p>Throughout both these presentations Stal mentions the need for iterative design and refactoring. He is clearly a strong supporter of refactoring. He realizes that all future software development can only be successful with decent and continuous refactorings. And he is far-sighted enough to see how refactoring can be applied not only to code but also other artifacts like architecture.</p>

<p>I was talking to Maurice and we both agree how our advisor, Ralph Johnson, could have made one of the greatest contributions to software engineering by introducing the concept of refactoring. Sure he has co-authored the book on Design Patterns but the main concept of refactoring is probably more influential. Thinking of software engineering in terms of refactoring and transformations is definitely how all future software should be developed.</p>
